/* define G */
.decl edge(u: symbol, v: symbol, c: number)
edge("s", "a", 5).
edge("a", "t", 2).
edge("s", "b", 1).
edge("b", "t", 1).

/* define G_f */
.decl frwd_edge(u: symbol, v: symbol, c: number, g: number)
.decl back_edge(u: symbol, v: symbol, c: number, g: number)

// all edges start with no flow at generation zero.
frwd_edge(u, v, c, 0) :- edge(u, v, c).
back_edge(v, u, 0, 0) :- edge(u, v, _).

.decl aug_path(u: symbol, v: symbol, c: number, g: number)
aug_path(x, y, c, g) :- frwd_edge(x, y, c, g).
aug_path(x, y, c, g) :- back_edge(x, y, c, g).

aug_path(x, z, c, g) :- frwd_edge(x, y, d, g), aug_path(y, z, e, g),
					    c = min(d, e), c > 0.
aug_path(x, z, c, g) :- back_edge(x, y, d, g), aug_path(y, z, e, g),
                        c = min(d, e), c > 0.

.decl s_t_flow(c: number, f: number, g: number)
s_t_flow(c, 0, 0) :- aug_path("s", "t", c, 0).
s_t_flow(c, c, g + 1) :- s_t_flow(c, f, g), f < c. 

.decl answer(f: number)
.output answer

answer(f) :- f = sum x : {s_t_flow(_, x, m), m = max g : s_t_flow(_, _, g)}.
