#define SOURCE "s"
#define SINK "t"

/* define G */
.decl edge(u: symbol, v: symbol, c: number)
edge("s", "a", 5).
edge("a", "t", 2).
edge("s", "b", 1).
edge("b", "t", 1).

/* define G_f */
.decl frwd_edge(u: symbol, v: symbol, c: number, g: number)
.decl back_edge(u: symbol, v: symbol, c: number, g: number)

// all edges start with no flow at generation zero.
frwd_edge(u, v, c, 0) :- edge(u, v, c).
back_edge(v, u, 0, 0) :- edge(u, v, _).

// record type to record variable-length paths
.type Path = [
    from : symbol,
    to : symbol,
    rest : Path
]

// associate each augmented path with a capacity
.decl aug_path(p: Path, c: number, g: number)
aug_path([u, SINK, nil], c, g) :- frwd_edge(u, SINK, c, g), c > 0.
aug_path([u, SINK, nil], c, g) :- back_edge(u, SINK, c, g), c > 0.


// TODO: why can't I use _ as variable name in `next`?
aug_path([u, v, next], c, g) :- frwd_edge(u, v, c_1, g), aug_path(next, c_2, g),
                                next = [v, y, z], c = min(c_1, c_2), c > 0.
aug_path([u, v, next], c, g) :- back_edge(u, v, c_1, g), aug_path(next, c_2, g),
                                next = [v, y, z], c = min(c_1, c_2), c > 0.

.decl s_t_path(id : number, p: Path, c: number, g: number)
.output s_t_path

s_t_path(ord(p), p, c, g) :- aug_path(p, c, g), p = [SOURCE, t, r].

.decl min_path(i: number, p: Path, c: number, g: number)
min_path(i, p, c, g) :- s_t_path(i, p, c, g), i = min k : s_t_path(k, _, _, g).

.decl chosen(p : Path, c: number, g: number)
.output chosen
chosen(p, c, g) :- min_path(_,p, c, g). 
chosen(p, c, g) :- chosen([u, v, p], c, g), p != nil.

.decl result(u: symbol, v: symbol, c: number, g: number)
.output result
result(u, v, c, g + 1) :- 
        chosen([u, v, next], c, g),
		frwd_edge(u, v, _, g).

result(u, v, -c, g + 1) :- 
        chosen([u, v, next], c, g),
		back_edge(u, v, _, g).

// .decl answer(f: number)
// .output answer

// answer(f) :- f = sum x : {s_t_flow(_, x, m), m = max g : s_t_flow(_, _, g)}.
