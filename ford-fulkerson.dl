/* define G */
.decl edge(u: symbol, v: symbol, c: number)
edge("s", "a", 5).
edge("a", "t", 2).
edge("s", "b", 1).
edge("b", "t", 1).

/* define G_f */
.decl frwd_edge(u: symbol, v: symbol, c: number, g: number)
.decl back_edge(u: symbol, v: symbol, c: number, g: number)

// all edges start with no flow at generation zero.
frwd_edge(u, v, c, 0) :- edge(u, v, c).
back_edge(v, u, 0, 0) :- edge(u, v, _).

// record type to record variable-length paths
.type Path = [
    from : symbol,
    to : symbol,
    rest : Path
]

// associate each augmented path with a capacity
.decl aug_path(p: Path, c: number, g: number)
aug_path([u, "t", nil], c, g) :- frwd_edge(u, "t", c, g), c > 0.
aug_path([u, "t", nil], c, g) :- back_edge(u, "t", c, g), c > 0.


// TODO: why can't I use _ as variable name in `next`?
aug_path([u, v, next], c, g) :- frwd_edge(u, v, c_1, g), aug_path(next, c_2, g),
                                next = [v, y, z], c = min(c_1, c_2), c > 0.
aug_path([u, v, next], c, g) :- back_edge(u, v, c_1, g), aug_path(next, c_2, g),
                                next = [v, y, z], c = min(c_1, c_2), c > 0.

.decl s_t_path(p: Path, c: number, g: number)
.output s_t_path

s_t_path(p, c, g) :- aug_path(p, c, g), p = ["s", t, r].

// .decl answer(f: number)
// .output answer

// answer(f) :- f = sum x : {s_t_flow(_, x, m), m = max g : s_t_flow(_, _, g)}.
